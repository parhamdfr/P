<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Flow Heart</title>
<style>
  body { margin: 0; background: #000; overflow: hidden; }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>

<script>

// Scene + Camera + Renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.z = 50;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Heart curve (2D â†’ extrude into 3D lines)
function heart2D(t) {
    return new THREE.Vector3(
        16 * Math.pow(Math.sin(t), 3),
        13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t),
        0
    );
}

// Generate flowing line points
const POINTS = 7000;
const pos = new Float32Array(POINTS * 3);
const flow = new Float32Array(POINTS);

for (let i = 0; i < POINTS; i++) {
    const t = Math.random() * Math.PI * 2;
    const base = heart2D(t);

    const jitterX = (Math.random() - 0.5) * 4;
    const jitterY = (Math.random() - 0.5) * 4;
    const jitterZ = (Math.random() - 0.5) * 6;

    pos[i*3] = base.x * 0.9 + jitterX;
    pos[i*3+1] = base.y * 0.9 + jitterY;
    pos[i*3+2] = jitterZ;

    flow[i] = t;
}

// Geometry
const geo = new THREE.BufferGeometry();
geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
geo.setAttribute("flow", new THREE.BufferAttribute(flow, 1));

// Shader material
const mat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
        time: { value: 0 }
    },
    vertexShader: `
        uniform float time;
        attribute float flow;
        varying float vFlow;

        void main() {
            vec3 p = position;

            // breathing pulse
            float pulse = 1.0 + 0.07 * sin(time * 2.0);
            p *= pulse;

            // flowing movement
            p.z += sin(flow * 4.0 + time * 4.0) * 3.0;

            vFlow = flow;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
        }
    `,
    fragmentShader: `
        varying float vFlow;
        uniform float time;

        void main() {
            float a = 0.6 + 0.4 * sin(vFlow * 4.0 + time * 6.0);
            vec3 color = vec3(
                1.0,
                0.2 + 0.3*sin(time*3.0),
                0.4 + 0.4*sin(time*2.0)
            );

            gl_FragColor = vec4(color, a);
        }
    `
});

// Points mesh
const mesh = new THREE.Points(geo, mat);
scene.add(mesh);

// Animate
function animate(t) {
    mat.uniforms.time.value = t * 0.001;

    mesh.rotation.y = t * 0.0003;
    mesh.rotation.x = Math.sin(t*0.0004) * 0.4;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate();

// Resize
onresize = () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};

</script>
</body>
</html>

